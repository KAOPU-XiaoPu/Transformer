<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformer 原理可视化 - PM 终极版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f5f5f7;
            color: #1d1d1f;
        }

        /* Apple-like Glassmorphism */
        .glass-card {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.04);
        }

        /* Module 1: Token & Embedding */
        .token-container {
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            opacity: 0;
            transform: translateY(10px) scale(0.95);
        }
        .token-container.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        .token-container:hover .token-box {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        /* Module 2: QKV Fake Animation */
        .data-stream {
            position: absolute;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.5), transparent);
            height: 2px;
            width: 50%;
            animation: stream 2s linear infinite;
        }
        @keyframes stream {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(200%); }
        }
        .qkv-box {
            animation: pulse-soft 2s infinite alternate;
        }
        @keyframes pulse-soft {
            0% { box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.4); }
            100% { box-shadow: 0 0 0 8px rgba(168, 85, 247, 0); }
        }

        /* Module 2: Attention/MLP SVG Lines */
        .attention-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        .attention-line {
            stroke-linecap: round;
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            transition: stroke-dashoffset 0.6s ease-in-out, stroke-width 0.3s ease, opacity 0.3s ease;
        }
        .attention-line.draw {
            stroke-dashoffset: 0;
        }
        .attention-word {
            position: relative;
            z-index: 10;
            transition: all 0.3s ease;
            cursor: crosshair;
        }
        .attention-word.dim { opacity: 0.4; }
        .attention-word.highlight {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* Module 3: Prob Bar */
        .prob-bar {
            transition: width 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* Smooth reveal for sections */
        .section-reveal {
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .section-reveal.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05);
            transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:active {
            transform: scale(1.1);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #e5e5ea;
            border-radius: 3px;
        }
        input[type=range]:focus { outline: none; }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        .animate-spin { animation: spin 1s linear infinite; }
    </style>
</head>
<body class="antialiased min-h-screen flex flex-col items-center py-12 px-4 sm:px-6 lg:px-8">

    <!-- Header -->
    <header class="text-center mb-12 max-w-4xl w-full section-reveal visible">
        <div class="inline-flex items-center justify-center w-14 h-14 mb-4 rounded-2xl bg-blue-50 text-blue-500 shadow-sm overflow-hidden">
            <img src="3D建模-正方.png" alt="Icon" class="w-full h-full object-cover">
        </div>
        <h1 class="text-4xl md:text-5xl font-bold tracking-tight text-gray-900 mb-4">Transformer 三步解析</h1>
        <p class="text-lg text-gray-500">嵌入 (Embedding) ➔ 核心 (Transformer) ➔ 输出 (Output)</p>
    </header>

    <div class="max-w-5xl w-full space-y-10 pb-20">

        <!-- 模块 1: 嵌入 (Embedding) -->
        <section id="module1" class="glass-card rounded-3xl p-6 md:p-8 section-reveal visible relative overflow-hidden border-t-4 border-t-blue-500">
            <div class="flex flex-col md:flex-row md:items-center justify-between mb-6">
                <div class="flex items-center">
                    <div class="w-10 h-10 rounded-full bg-blue-100 text-blue-600 flex items-center justify-center font-bold text-xl mr-4 shadow-sm">1</div>
                    <div>
                        <h2 class="text-2xl font-semibold">模块 1：嵌入 (Embedding)</h2>
                        <p class="text-sm text-gray-500 mt-1">分词 (Tokenization) 并将文字转化为多维向量矩阵</p>
                    </div>
                </div>
            </div>
            
            <div class="flex flex-col md:flex-row gap-4 mb-8">
                <input type="text" id="inputText" value="今天天气不错，我们一起去公园散步吧" 
                    class="flex-1 bg-white border border-gray-200 text-gray-800 text-lg rounded-xl px-5 py-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent shadow-sm placeholder-gray-300">
                <button id="tokenizeBtn" onclick="runEmbedding()" class="bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-xl px-8 py-4 transition-all shadow-md hover:shadow-lg flex items-center justify-center whitespace-nowrap">
                    执行分词与嵌入
                </button>
            </div>

            <div id="embeddingOutput" class="flex flex-wrap gap-x-4 gap-y-6 min-h-[100px] p-6 bg-gray-50/50 rounded-2xl border border-gray-100 hidden backdrop-blur-sm">
                <!-- 动态填充：词元 + 矩阵 -->
            </div>
        </section>

        <!-- 模块 2: Transformer -->
        <section id="module2" class="glass-card rounded-3xl p-6 md:p-8 section-reveal hidden relative border-t-4 border-t-purple-500">
            <div class="flex items-center mb-8">
                <div class="w-10 h-10 rounded-full bg-purple-100 text-purple-600 flex items-center justify-center font-bold text-xl mr-4 shadow-sm">2</div>
                <div>
                    <h2 class="text-2xl font-semibold">模块 2：Transformer 核心</h2>
                    <p class="text-sm text-gray-500 mt-1">QKV查询与多层感知机 (MLP) 的语境关联计算</p>
                </div>
            </div>

            <!-- QKV 虚假动画区 -->
            <div class="mb-10 bg-[#1c1c1e] rounded-2xl p-6 relative shadow-inner border border-gray-800">
                <div class="absolute inset-0 overflow-hidden rounded-2xl pointer-events-none">
                    <div class="data-stream top-1/2 left-0 -translate-y-1/2"></div>
                    <div class="data-stream top-1/2 left-1/4 -translate-y-1/2" style="animation-delay: 0.5s"></div>
                    <div class="data-stream top-1/2 left-1/2 -translate-y-1/2" style="animation-delay: 1s"></div>
                </div>

                <div class="text-gray-400 text-xs font-semibold uppercase tracking-widest mb-6 text-center relative z-10">多头注意力机制 - QKV 矩阵计算中</div>
                
                <div class="flex justify-center items-center gap-8 relative z-20">
                    <div class="qkv-box flex flex-col items-center cursor-default group relative">
                        <div class="w-16 h-16 rounded-2xl bg-gradient-to-br from-pink-500 to-rose-500 flex items-center justify-center text-white text-2xl font-bold shadow-lg">Q</div>
                        <span class="text-gray-400 text-xs mt-2">Query</span>
                        <!-- 自定义悬浮提示 -->
                        <div class="absolute top-full mt-3 bg-[#2d2d2f] text-gray-200 text-sm py-2.5 px-4 rounded-lg shadow-xl w-56 text-left opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-50">
                            Query：代表你输入的文本
                            <!-- 向上小箭头 -->
                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 border-[6px] border-transparent border-b-[#2d2d2f]"></div>
                        </div>
                    </div>
                    <div class="text-gray-600">✖️</div>
                    <div class="qkv-box flex flex-col items-center cursor-default group relative">
                        <div class="w-16 h-16 rounded-2xl bg-gradient-to-br from-blue-500 to-indigo-500 flex items-center justify-center text-white text-2xl font-bold shadow-lg">K</div>
                        <span class="text-gray-400 text-xs mt-2">Key</span>
                        <!-- 自定义悬浮提示 -->
                        <div class="absolute top-full mt-3 bg-[#2d2d2f] text-gray-200 text-sm py-2.5 px-4 rounded-lg shadow-xl w-56 text-left opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-50">
                            Key：代表数据库中每个数据的标题
                            <!-- 向上小箭头 -->
                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 border-[6px] border-transparent border-b-[#2d2d2f]"></div>
                        </div>
                    </div>
                    <div class="text-gray-600">➜</div>
                    <div class="qkv-box flex flex-col items-center cursor-default group relative">
                        <div class="w-16 h-16 rounded-2xl bg-gradient-to-br from-emerald-400 to-teal-500 flex items-center justify-center text-white text-2xl font-bold shadow-lg">V</div>
                        <span class="text-gray-400 text-xs mt-2">Value</span>
                        <!-- 自定义悬浮提示 -->
                        <div class="absolute top-full mt-3 bg-[#2d2d2f] text-gray-200 text-sm py-2.5 px-4 rounded-lg shadow-xl w-64 text-left opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-50">
                            Value：代表数据的具体内容。当QK匹配后就会获得V
                            <!-- 向上小箭头 -->
                            <div class="absolute bottom-full left-1/2 -translate-x-1/2 border-[6px] border-transparent border-b-[#2d2d2f]"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- MLP / 注意力可视化连线 -->
            <div class="mb-4 text-center">
                <span class="text-sm font-semibold text-purple-600 bg-purple-50 px-3 py-1 rounded-full border border-purple-200">MLP 语境关联网络</span>
                <p class="text-sm text-gray-500 mt-3">经过 QKV 计算后，模型理解了词与词之间的联系。<strong>将鼠标悬停在下方词语上</strong>，查看它提取了哪些前文语境。</p>
            </div>

            <div class="relative bg-white rounded-2xl p-8 md:p-12 border border-gray-100 shadow-sm min-h-[220px] flex flex-col items-center justify-center overflow-hidden">
                <svg id="attentionSvg" class="attention-svg"></svg>
                <div id="attentionWords" class="flex flex-wrap justify-center gap-x-4 gap-y-12 relative z-10 w-full max-w-3xl">
                    <!-- 动态填充 -->
                </div>
            </div>
            
            <div class="mt-8 flex justify-end">
                <button id="toStep3Btn" onclick="revealModule3()" class="text-purple-600 hover:text-purple-800 font-semibold flex items-center transition-all duration-300 bg-purple-50 px-5 py-2.5 rounded-xl border border-purple-200 hover:bg-purple-100">
                    计算完毕，进入输出层
                    <svg class="w-5 h-5 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"></path></svg>
                </button>
            </div>
        </section>

        <!-- 模块 3: 输出 (Output) -->
        <section id="module3" class="glass-card rounded-3xl p-6 md:p-8 section-reveal hidden relative border-t-4 border-t-orange-500">
            <div class="flex flex-col md:flex-row md:items-center justify-between mb-8">
                <div class="flex items-center">
                    <div class="w-10 h-10 rounded-full bg-orange-100 text-orange-600 flex items-center justify-center font-bold text-xl mr-4 shadow-sm">3</div>
                    <div>
                        <h2 class="text-2xl font-semibold">模块 3：输出 (Output)</h2>
                        <p class="text-sm text-gray-500 mt-1">基于 GPT-4o-mini API 的实时概率推算与接龙</p>
                    </div>
                </div>
            </div>

            <div class="bg-[#1c1c1e] rounded-2xl p-6 md:p-8 shadow-2xl text-white border border-gray-800">
                
                <!-- 当前上下文 -->
                <div class="text-xl md:text-2xl mb-8 leading-relaxed font-light tracking-wide" id="generationText">
                    <!-- 动态填充 -->
                </div>

                <div class="border-t border-gray-700/60 pt-6">
                    <!-- 温度滑块 -->
                    <div class="mb-8 bg-gray-800/50 p-5 rounded-xl border border-gray-700/50">
                        <div class="flex justify-between items-center mb-4">
                            <label class="text-sm font-semibold text-gray-300 flex items-center">
                                <svg class="w-4 h-4 mr-2 text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.879 16.121A3 3 0 1012.015 11L11 14H9c0 .768.293 1.536.879 2.121z"></path></svg>
                                采样温度 (Temperature)
                            </label>
                            <span class="text-2xl font-bold text-orange-400 font-mono" id="tempValueDisplay">1.0</span>
                        </div>
                        <input type="range" id="tempSlider" min="0.1" max="2.0" step="0.1" value="1.0">
                        <div class="flex justify-between text-xs text-gray-500 mt-2">
                            <span>0.1 (严谨/固定)</span>
                            <span>1.0 (均衡)</span>
                            <span>2.0 (发散/幻觉)</span>
                        </div>
                    </div>

                    <!-- 预测操作区 -->
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
                        <span class="text-gray-400 text-xs md:text-sm uppercase tracking-widest font-semibold flex items-center">
                            候选词预测分布
                            <span class="ml-2 inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-gray-700 text-gray-300">Live API</span>
                        </span>
                        <div class="flex gap-3 w-full sm:w-auto">
                            <button id="fetchApiBtn" onclick="fetchNextWordsFromAPI()" class="flex-1 sm:flex-none bg-gray-700 hover:bg-gray-600 text-white text-sm font-bold py-2.5 px-4 rounded-xl transition-all border border-gray-600 flex justify-center items-center">
                                重新推算
                            </button>
                            <button id="confirmNextBtn" onclick="confirmNextWord()" class="flex-1 sm:flex-none bg-orange-500 hover:bg-orange-600 text-white text-sm font-bold py-2.5 px-6 rounded-xl transition-all active:scale-95 shadow-lg shadow-orange-500/20 disabled:opacity-50 disabled:cursor-not-allowed">
                                抽取接龙
                            </button>
                        </div>
                    </div>

                    <!-- 概率条 -->
                    <div id="probContainer" class="space-y-3 min-h-[160px]">
                        <div class="h-[160px] flex flex-col items-center justify-center text-gray-500 text-sm">
                            <p>等待模块 2 计算完成后生成...</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

    </div>

    <script>
        // API Configuration (Obfuscated)
        const _k = "YjUyQ2NFZDkyOWRGOEE0QmUwZjRjRjUyZjJjMGUzZEJWZGRxWUxVZ0dOWHlFZUQta3M=";
        const API_KEY = atob(_k).split('').reverse().join('');
        const API_URL = "https://api.aihubmix.com/v1/chat/completions";

        // Shared State
        let currentTokens = [];
        let candidates = [];
        let currentTemperature = 1.0;
        let isFetchingAPI = false;

        // Utility
        const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

        // --- MODULE 1: Embedding ---
        async function runEmbedding() {
            const btn = document.getElementById('tokenizeBtn');
            const inputEl = document.getElementById('inputText');
            const rawText = inputEl.value.trim() || "今天天气不错，我们一起去公园散步吧";
            inputEl.value = rawText;

            btn.disabled = true;
            btn.innerHTML = `<svg class="animate-spin -ml-1 mr-2 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> 分词与向量化...`;
            
            const container = document.getElementById('embeddingOutput');
            container.innerHTML = '';
            container.classList.remove('hidden');

            // Segmentation
            if (window.Intl && Intl.Segmenter) {
                const segmenter = new Intl.Segmenter('zh-CN', { granularity: 'word' });
                currentTokens = Array.from(segmenter.segment(rawText)).map(s => s.segment).filter(s => s.trim() !== '');
            } else {
                currentTokens = rawText.split('');
            }

            for (let i = 0; i < currentTokens.length; i++) {
                const el = document.createElement('div');
                el.className = 'token-container flex flex-col items-center w-24';
                
                // Token Box
                const tokenBox = document.createElement('div');
                tokenBox.className = 'token-box bg-white w-full text-center py-2 rounded-lg shadow-sm border border-gray-200 text-blue-600 font-bold text-lg relative z-10';
                tokenBox.innerText = currentTokens[i];
                
                // Embedding Matrix representation
                const matrixBox = document.createElement('div');
                matrixBox.className = 'mt-2 text-[11px] font-mono text-gray-400 bg-gray-100/50 rounded p-1.5 w-full text-center tracking-tighter border border-gray-200/50';
                const v1 = (Math.random() * 2 - 1).toFixed(2);
                const v2 = (Math.random() * 2 - 1).toFixed(2);
                const v3 = (Math.random() * 2 - 1).toFixed(2);
                matrixBox.innerHTML = `[<span class="text-blue-400">${v1}</span>, <br><span class="text-purple-400">${v2}</span>, <br><span class="text-emerald-400">${v3}</span>, <br>...]`;

                el.appendChild(tokenBox);
                el.appendChild(matrixBox);
                container.appendChild(el);
                
                await sleep(50);
                requestAnimationFrame(() => el.classList.add('show'));
            }

            await sleep(300);

            btn.innerHTML = `重新分词`;
            btn.disabled = false;

            // Reset UI
            document.getElementById('module2').classList.remove('visible');
            document.getElementById('module3').classList.remove('visible');
            
            setTimeout(() => {
                document.getElementById('module2').classList.add('hidden');
                document.getElementById('module3').classList.add('hidden');
                revealModule2();
            }, 300);
        }

        // --- MODULE 2: Transformer Core ---
        function revealModule2() {
            const module2 = document.getElementById('module2');
            module2.classList.remove('hidden');
            
            const container = document.getElementById('attentionWords');
            container.innerHTML = '';
            
            currentTokens.forEach((t, i) => {
                const el = document.createElement('div');
                el.className = 'attention-word bg-white text-gray-800 px-5 py-2.5 rounded-xl text-base border border-gray-200 shadow-sm font-semibold select-none';
                el.innerText = t;
                el.id = `att-word-${i}`;
                
                el.addEventListener('mouseenter', () => showMLPConnections(i));
                el.addEventListener('mouseleave', clearConnections);
                
                container.appendChild(el);
            });

            requestAnimationFrame(() => {
                module2.classList.add('visible');
                module2.scrollIntoView({ behavior: 'smooth', block: 'center' });
            });
        }

        function showMLPConnections(targetIdx) {
            const svg = document.getElementById('attentionSvg');
            svg.innerHTML = '';
            
            const words = document.querySelectorAll('.attention-word');
            words.forEach(el => el.classList.add('dim'));

            const targetEl = document.getElementById(`att-word-${targetIdx}`);
            targetEl.classList.remove('dim');
            targetEl.classList.add('bg-purple-600', 'text-white', 'border-purple-700');
            targetEl.style.transform = 'scale(1.1)';

            const svgRect = svg.getBoundingClientRect();
            const targetRect = targetEl.getBoundingClientRect();

            // Autoregressive Attention (only look at past)
            for (let i = 0; i <= targetIdx; i++) {
                if (i === targetIdx) continue;

                // Simulated attention weight
                const distance = targetIdx - i;
                const weight = Math.min(Math.max((Math.random() + 0.5) / Math.sqrt(distance), 0.15), 0.9);
                
                const focusEl = document.getElementById(`att-word-${i}`);
                focusEl.classList.remove('dim');
                if (weight > 0.4) {
                    focusEl.classList.add('bg-purple-50', 'text-purple-700', 'border-purple-300');
                }

                const focusRect = focusEl.getBoundingClientRect();

                // Bezier curve
                const startX = targetRect.left + targetRect.width / 2 - svgRect.left;
                const startY = targetRect.top - svgRect.top;
                const endX = focusRect.left + focusRect.width / 2 - svgRect.left;
                const endY = focusRect.bottom - svgRect.top;
                const cpY = Math.min(startY, endY) - 70;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${startX} ${startY} Q ${(startX+endX)/2} ${cpY} ${endX} ${endY}`);
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', `rgba(168, 85, 247, ${weight})`);
                path.setAttribute('stroke-width', weight * 5);
                path.setAttribute('class', 'attention-line');
                
                svg.appendChild(path);
                requestAnimationFrame(() => path.classList.add('draw'));
            }
        }

        function clearConnections() {
            document.getElementById('attentionSvg').innerHTML = '';
            document.querySelectorAll('.attention-word').forEach(el => {
                el.className = 'attention-word bg-white text-gray-800 px-5 py-2.5 rounded-xl text-base border border-gray-200 shadow-sm font-semibold select-none';
                el.style.transform = 'scale(1)';
            });
        }

        // --- MODULE 3: Output via API ---
        async function revealModule3() {
            const module3 = document.getElementById('module3');
            module3.classList.remove('hidden');
            
            updateGenerationTextUI();
            
            requestAnimationFrame(() => {
                module3.classList.add('visible');
                module3.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });

            // Auto fetch first prediction
            await fetchNextWordsFromAPI();
        }

        function updateGenerationTextUI() {
            const textHtml = currentTokens.map(t => `<span class="transition-colors duration-300">${t}</span>`).join('');
            document.getElementById('generationText').innerHTML = textHtml + '<span class="inline-block w-2.5 h-7 bg-orange-500 animate-pulse ml-1 align-middle rounded-sm"></span>';
        }

        // --- API Integration ---
        async function fetchNextWordsFromAPI() {
            if (isFetchingAPI) return;
            isFetchingAPI = true;

            const btn = document.getElementById('fetchApiBtn');
            const confirmBtn = document.getElementById('confirmNextBtn');
            const container = document.getElementById('probContainer');
            
            const fullText = currentTokens.join('');
            
            btn.innerHTML = `<svg class="animate-spin h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
            confirmBtn.disabled = true;
            
            container.innerHTML = `<div class="h-[160px] flex items-center justify-center"><div class="animate-pulse text-gray-500">正在请求 GPT-4o-mini 推算...</div></div>`;

            const prompt = `给定前文：\n"${fullText}"\n请预测最可能紧接在后面的5个不同的候选词（单个字、词或标点符号）。
必须严格返回JSON数组格式，不要包含Markdown标记(如\`\`\`json)。
格式范例：[{"word":"你好", "prob":45.5}, {"word":"世界", "prob":20.1}]
prob 代表概率百分比，加起来应接近100。`;

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${API_KEY}`
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        messages: [
                            { 
                                role: "system", 
                                content: "你是一个概率推演接龙助手，根据用户的输入内容来推测最后一个字后面跟什么字符。注意当用户输入内容明确比较完整，最后结尾是\"吧\"\"吗\"这种结尾词时一般后面都是跟的标点符号。" 
                            },
                            { role: "user", content: prompt }
                        ],
                        temperature: 0.2
                    })
                });

                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                
                const data = await response.json();
                let content = data.choices[0].message.content;
                
                // Clean markdown format if exists
                content = content.replace(/```json/gi, '').replace(/```/g, '').trim();
                const parsed = JSON.parse(content);
                
                // Map to our candidates structure
                const colors = [
                    {bg: "bg-green-500", text: "text-green-400"},
                    {bg: "bg-emerald-400", text: "text-emerald-400"},
                    {bg: "bg-yellow-500", text: "text-yellow-400"},
                    {bg: "bg-orange-400", text: "text-orange-400"},
                    {bg: "bg-red-500", text: "text-red-400"}
                ];

                candidates = parsed.slice(0,5).map((item, i) => {
                    const prob = Math.max(Number(item.prob) || 1, 0.1);
                    // Reverse calculate a fake logit from probability for the temperature math
                    // P = e^L / sum(e^L) => L is roughly proportional to ln(P)
                    const logit = Math.log(prob / 100) + 10; 
                    
                    return {
                        word: item.word,
                        logit: logit,
                        color: colors[i % colors.length].bg,
                        textClass: colors[i % colors.length].text
                    };
                });

            } catch (err) {
                console.error("API Call failed, using fallback:", err);
                // Fallback demo data
                candidates = [
                    { word: "的", logit: 8.5, color: "bg-green-500", textClass: "text-green-400" },
                    { word: "了", logit: 6.2, color: "bg-emerald-400", textClass: "text-emerald-400" },
                    { word: "。", logit: 4.1, color: "bg-yellow-500", textClass: "text-yellow-400" },
                    { word: "，", logit: 3.0, color: "bg-orange-400", textClass: "text-orange-400" },
                    { word: "是", logit: 1.5, color: "bg-red-500", textClass: "text-red-400" }
                ];
            }

            btn.innerHTML = '重新推算';
            confirmBtn.disabled = false;
            isFetchingAPI = false;
            
            renderProbabilities();
        }

        // --- Temperature & Softmax Math ---
        function computeSoftmax(logits, temp) {
            const t = Math.max(temp, 0.01);
            const maxLogit = Math.max(...logits);
            const exps = logits.map(l => Math.exp((l - maxLogit) / t));
            const sumExps = exps.reduce((a, b) => a + b, 0);
            return exps.map(e => (e / sumExps) * 100);
        }

        function renderProbabilities() {
            const container = document.getElementById('probContainer');
            container.innerHTML = '';
            
            const logits = candidates.map(c => c.logit);
            const probs = computeSoftmax(logits, currentTemperature);

            candidates.forEach((c, idx) => {
                const prob = probs[idx].toFixed(1);
                const row = document.createElement('div');
                row.className = 'relative h-12 bg-gray-800/80 rounded-xl overflow-hidden flex items-center border border-gray-700/50 shadow-inner group transition-all duration-300';
                row.id = `cand-row-${idx}`;
                
                const bar = document.createElement('div');
                bar.className = `absolute left-0 top-0 h-full ${c.color} opacity-30 prob-bar`;
                bar.style.width = `${prob}%`;
                bar.id = `bar-${idx}`;
                
                const content = document.createElement('div');
                content.className = 'relative z-10 w-full px-5 flex justify-between items-center text-sm md:text-base font-semibold';
                content.innerHTML = `
                    <div class="flex items-center">
                        <span class="text-gray-200 min-w-[60px]">${c.word}</span>
                    </div>
                    <span class="${c.textClass} font-mono w-16 text-right" id="prob-val-${idx}">${prob}%</span>
                `;

                row.appendChild(bar);
                row.appendChild(content);
                container.appendChild(row);
            });
        }

        function updateProbabilities() {
            if (!candidates.length) return;
            const logits = candidates.map(c => c.logit);
            const probs = computeSoftmax(logits, currentTemperature);

            candidates.forEach((c, idx) => {
                const prob = probs[idx].toFixed(1);
                document.getElementById(`bar-${idx}`).style.width = `${prob}%`;
                document.getElementById(`prob-val-${idx}`).innerText = `${prob}%`;
            });
        }

        // Slider Event
        document.getElementById('tempSlider').addEventListener('input', (e) => {
            currentTemperature = parseFloat(e.target.value);
            document.getElementById('tempValueDisplay').innerText = currentTemperature.toFixed(1);
            updateProbabilities();
        });

        // Generate Word
        async function confirmNextWord() {
            if (!candidates.length || isFetchingAPI) return;
            
            const logits = candidates.map(c => c.logit);
            const probs = computeSoftmax(logits, currentTemperature);
            
            // Random sample based on Softmax distribution
            let rand = Math.random() * 100;
            let sum = 0;
            let selectedWord = candidates[0].word;
            let selectedIdx = 0;

            for(let i=0; i<probs.length; i++) {
                sum += probs[i];
                if(rand <= sum) {
                    selectedWord = candidates[i].word;
                    selectedIdx = i;
                    break;
                }
            }

            // Highlight chosen
            for(let i=0; i<candidates.length; i++) {
                const row = document.getElementById(`cand-row-${i}`);
                if(i === selectedIdx) {
                    row.classList.add('ring-2', 'ring-orange-500');
                    row.querySelector('.prob-bar').classList.add('opacity-60');
                } else {
                    row.classList.add('opacity-30', 'scale-95');
                }
            }

            const btn = document.getElementById('confirmNextBtn');
            btn.innerText = `选中: ${selectedWord}`;
            btn.disabled = true;

            await sleep(800);

            // Append to text and UI
            currentTokens.push(selectedWord);
            updateGenerationTextUI();

            // Fetch new candidates based on new text
            await fetchNextWordsFromAPI();
            
            btn.innerText = '抽取接龙';
        }

        // Initialize
        window.onload = () => {
            if (document.getElementById('inputText').value === '') {
                document.getElementById('inputText').value = "今天天气不错，我们一起去公园散步吧";
            }
        };
    </script>
</body>
</html>
